..
    Copyright (c) 2018 Bobby Noelte
    SPDX-License-Identifier: Apache-2.0

.. _codegen_modules:

Code Generation Modules
#######################

Code generation modules provide supporting functions for code generation.

.. contents::
   :depth: 2
   :local:
   :backlinks: top

Modules have to be imported to gain access to the module's functions
and variables.

 ::

    /* This file uses modules. */
    ...
    /**
     * @code{.codegen}
     * codegen.import_module('my_special_module')
     * my_special_module.do_everything():
     * @endcode{.codegen}
     */
    /** @code{.codeins}@endcode */
    ...

Device declare module
*********************

::

    codegen.import_module('devicedeclare')

The devicedeclare module provides functions to generate driver device
instantiations.

Driver info templates
---------------------

The device declaration functions work on templates that feature placeholder
substitution.

Device instance property placeholders:

- ${device-name}: device instance name.
                  Name is generated by the declaration function.
- ${driver-name}: device instance driver name.
                  Name is taken from the device tree node property 'label'.
- ${device-data}: device instance data structure name.
                  Name is generated by the declaration function.
- ${device-config-info}: device instance configuration structure name.
                         Name is generated by the declaration function.
- ${device-config-irq}: device instance interrupt configuration function name.
                        Name is generated by the declaration function.

Device instance device tree property placeholders:

* ${[path to DTS property]}: device instance device tree node property.
    The property path supports every node property that is documented in the
    node yaml bindings. It also supports yaml heuristics, like 'bus-master' and
    will use documented '"#cells"'.

Device tree property placeholders:

- ${[device id]:[path to DTS property]}: device node property value.
    The device node property is defined by the property path of the device
    given by the device id.
    The device id is usually also taken from a DTS property e.g.
    ${${clocks/0/provider}:device-name}.

KConfig configuration parameter placeholders:

- ${CONFIG_[configuration parameter]}: KConfig configuration parameter value.

Declaration of device instances
-------------------------------

.. function:: devicedeclare.device_declare(compatibles, init_prio_flag, kernel_level, irq_func, init_func, api, data_struct, config_struct)

    Generate device instances code for all devices activated ('status' = 'ok')
    in the board device tree file matching the provided compatibles.

    Most of the parameters aim at filling the DEVICE_AND_API_INIT macro.
    Other parameters are there to help code generation to fit driver specifics.

    Instance code will only be generated if the Kconfig variable is set. The
    variable name is build with the device node label name (e.g: CONFIG_I2C_1).

    :param compatibles: List of compatibles supported by the driver
                        (e.g. ['st,stm32-spi-fifo', 'st,stm32-spi'])
    :param init_prio_flag: Flag for driver activation priority
                           (e.g. CONFIG_KERNEL_INIT_PRIORITY_DEVICE)
    :param kernel_level: Flag for driver activation priority (e.g. POST_KERNEL)
    :param irq_func: Two elements python dict providing driver isr function
                     prefix (e.g. 'irq_func' \: 'stm32_i2c_isr') and flag to be
                     used for driver IRQ code control
                     (e.g. 'irq_flag' \: 'CONFIG_I2C_STM32_INTERRUPT').
                     If irq_func is 'None', no IRQ code is generated.
                     'device_declare' will  generate as much IRQ code as
                     declared by device node.
                     If the 'interrupts-names' property is provided in the node,
                     isr names will be generated using matching values as
                     function postfixes.
    :param init_func: Name of the driver init function (e.g. 'i2c_stm32_init').
    :param api: Name of the driver api structure  (e.g. 'api_funcs').
    :param data_struct: Two elements python list providing elements for driver
                        '_data' structure generation.
    :param config_struct: Two elements python list providing elements for driver
                          '_config' structure generation.

'data_struct' and 'config_struct' will be processed the same way:

* First element (e.g. 'i2c_stm32_config') should be the structure name.
* Second element is a 'c' template code between triple double quotes (""" """).
    It should provide the expected code to be generated for the structure.
    For instance:

.. code-block:: python

    """
    	.i2c = (I2C_TypeDef *)${reg/0/address/0},
    	.pclken = {
    			.enr = ${clocks/0/bits},
    			.bus = ${clocks/0/bus},
    	},
    #ifdef CONFIG_I2C_STM32_INTERRUPT
    	.irq_config_func = st_stm32_i2c_v1_${node_index}_config_irq,
    #endif
    	.bitrate = ${clock-frequency},
    """

If the second element of 'data_struct' or 'config_struct' list is not provided,
an empty structure is generated.

Finally, for the above depicted example, 'device_declare' will generate,
for device instance 'I2C1':

.. code-block:: c

    #ifdef CONFIG_I2C_STM32_INTERRUPT
    DEVICE_DECLARE(st_stm32_i2c_v1_i2c_1);
    static void st_stm32_i2c_v1_i2c_1_config_irq(struct device *dev)
    {
    	IRQ_CONNECT(31,
    		0,
    		stm32_i2c_isr_event,
    		DEVICE_GET(st_stm32_i2c_v1_i2c_1),
    		0);
    	irq_enable(31);
    	IRQ_CONNECT(32,
    		0,
    		stm32_i2c_isr_error,
    		DEVICE_GET(st_stm32_i2c_v1_i2c_1),
    		0);
    	irq_enable(32);
    }
    #endif /* CONFIG_I2C_STM32_INTERRUPT */

    static const struct i2c_stm32_config st_stm32_i2c_v1_i2c_1_config = {
    	.i2c = (I2C_TypeDef *)0x40005400,
    	.pclken = {
    		.enr = 131072,
    		.bus = 2,
    	},
    #ifdef CONFIG_I2C_STM32_INTERRUPT
    	.irq_config_func = st_stm32_i2c_v1_i2c_1_config_irq,
    #endif
    	.bitrate = 400000,
    };

    static struct i2c_stm32_data st_stm32_i2c_v1_i2c_1_data = {};

    DEVICE_AND_API_INIT(st_stm32_i2c_v1_i2c_1,
    	"I2C_1",
    	i2c_stm32_init,
    	&st_stm32_i2c_v1_i2c_1_data,
    	&st_stm32_i2c_v1_i2c_1_config,
    	POST_KERNEL,
    	CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
    	&api_funcs);

Raw declaration of a single device instance
-------------------------------------------

.. function:: devicedeclare.device_declare_single(device_config, driver_name, device_init, device_levels device_prio, device_api, device_info)

    Generate device instances code for a device instance that:

    - matches the driver name and that
    - is activated ('status' = 'ok') in the board device tree file and that is
    - configured by Kconfig.

    The ``device_declare_single`` function enables a detailed control of the
    device info definition. It's primary use is for complex device instance
    initialisation that can not be accomplished by ``device_declare``.

    :param device_config:
        Configuration variables for device instantiation.
        (e.g. 'CONFIG_SPI_0')
    :param driver_name:
        Driver name for device instantiation.
        (e.g. 'SPI_0')
    :param device_init:
        Device initialisation function.
        (e.g. 'spi_stm32_init')
    :param device_level:
        Driver initialisation level.
        (e.g. 'PRE_KERNEL_1')
    :param device_prios:
        Driver initialisation priority definition.
        (e.g. 32)
    :param device_api:
        Identifier of the device api.
        (e.g. 'spi_stm32_driver_api')
    :param device_info:
        Device info template for device driver config, data and interrupt
        initialisation.
    :param device_defaults:
        Default property values.
        (e.g. { 'label' : 'My default label' })

Raw declaration of multiple device instances
--------------------------------------------

.. function:: devicedeclare.device_declare_multi(device_configs, driver_names, device_inits, device_levels, device_prios, device_api, device_info)

    Generate device instances code for all device instances that:

    - match the driver names and that
    - are activated ('status' = 'ok') in the board device tree file and that are
    - configured by Kconfig.

    The ``device_declare_multi`` function enables a detailed control of the
    device info definition. It's primary use is for complex device instance
    initialisation that can not be accomplished by ``device_declare``.

    :param device_configs:
        A list of configuration variables for device instantiation.
        (e.g. ['CONFIG_SPI_0', 'CONFIG_SPI_1'])
    :param driver_names:
        A list of driver names for device instantiation. The list shall be
        ordered the same way as the list of device configs.
        (e.g. ['SPI_0', 'SPI_1'])
    :param device_inits:
        A list of device initialisation functions or a one single function.
        The list shall be ordered as the list of device configs.
        (e.g. 'spi_stm32_init')
    :param device_levels:
        A list of driver initialisation levels or one single level definition.
        The list shall be ordered as the list of device configs.
        (e.g. 'PRE_KERNEL_1')
    :param device_prios:
        A list of driver initialisation priorities or one single priority
        definition. The list shall be ordered as the list of device configs.
        (e.g. 32)
    :param device_api:
        Identifier of the device api.
        (e.g. 'spi_stm32_driver_api')
    :param device_info:
        Device info template for device driver config, data and interrupt
        initialisation.
    :param device_defaults:
        Default property values.
        (e.g. { 'label' : 'My default label' })

Example:

.. code-block:: C

    /**
     * @code{.codegen}
     * codegen.import_module('devicedeclare')
     *
     * device_configs = ['CONFIG_SPI_{}'.format(x) for x in range(1, 4)]
     * driver_names = ['SPI_{}'.format(x) for x in range(1, 4)]
     * device_inits = 'spi_stm32_init'
     * device_levels = 'POST_KERNEL'
     * device_prios = 'CONFIG_SPI_INIT_PRIORITY'
     * device_api = 'spi_stm32_driver_api'
     * device_info = \
     * """
     * #if CONFIG_SPI_STM32_INTERRUPT
     * DEVICE_DECLARE(${device-name});
     * static void ${device-config-irq}(struct device *dev)
     * {
     *         IRQ_CONNECT(${interrupts/0/irq}, ${interrupts/0/priority}, \\
     *                     spi_stm32_isr, \\
     *                     DEVICE_GET(${device-name}), 0);
     *         irq_enable(${interrupts/0/irq});
     * }
     * #endif
     * static const struct spi_stm32_config ${device-config-info} = {
     *         .spi = (SPI_TypeDef *)${reg/0/address/0},
     *         .pclken.bus = ${clocks/0/bus},
     *         .pclken.enr = ${clocks/0/bits},
     * #if CONFIG_SPI_STM32_INTERRUPT
     *         .config_irq = ${device-config-irq},
     * #endif
     * };
     * static struct spi_stm32_data ${device-data} = {
     *         SPI_CONTEXT_INIT_LOCK(${device-data}, ctx),
     *         SPI_CONTEXT_INIT_SYNC(${device-data}, ctx),
     * };
     * """
     *
     * devicedeclare.device_declare_multi( \
     *     device_configs,
     *     driver_names,
     *     device_inits,
     *     device_levels,
     *     device_prios,
     *     device_api,
     *     device_info)
     * @endcode{.codegen}
     */
    /** @code{.codeins}@endcode */
